<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Turbopack初识 | iiLsss</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://iilsss.github.io//blog/Turbopack"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Turbopack初识 | iiLsss"><meta data-rh="true" name="description" content="Turbopack 建立在新的增量架构上，以提供最快的开发体验。 在大型应用程序上，它显示更新速度比 Vite 快 10 倍，比 Webpack 快 700 倍。 在更大的应用程序上，差异更大——通常比 Vite 快 20 倍。"><meta data-rh="true" property="og:description" content="Turbopack 建立在新的增量架构上，以提供最快的开发体验。 在大型应用程序上，它显示更新速度比 Vite 快 10 倍，比 Webpack 快 700 倍。 在更大的应用程序上，差异更大——通常比 Vite 快 20 倍。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2022-10-29T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="Turbopack,Webpack,Vite"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://iilsss.github.io//blog/Turbopack"><link data-rh="true" rel="alternate" href="https://iilsss.github.io//blog/Turbopack" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://iilsss.github.io//blog/Turbopack" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="iiLsss RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="iiLsss Atom Feed"><link rel="stylesheet" href="/assets/css/styles.28aaf335.css">
<link rel="preload" href="/assets/js/runtime~main.8769d743.js" as="script">
<link rel="preload" href="/assets/js/main.44404fa1.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><b class="navbar__title text--truncate">地球</b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/docs/intro/">Note</a><a class="navbar__item navbar__link header-react-link" href="/docs/react/">React</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">More</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/interview/">📙 知识体系</a></li><li><a class="dropdown__link" href="/tool">🛠️ 工具</a></li></ul></div><a href="https://github.com/iiLsss/iiLsss.github.io" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">全部博文</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/server-component">理解 React 服务器组件</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/08/01/webpack-mf">基于Webpack的模块联邦特性实现微前端</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/2023/05/06/structuredClone">使用 structuredClone 方法进行深拷贝</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/async">实现大量异步任务串行</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/env-var">自定义环境变量模式</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/uml">Picturing Architecture</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/Turbopack">Turbopack初识</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/docusaurus">hexo转docusaurus</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/mac-config">Mac开发环境配置&amp;快捷键</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/welcome">Welcome</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/mdx-blog-post">MDX Blog Post</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/long-blog-post">Long Blog Post</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/first-blog-post">First Blog Post</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/es6-blog-post">ES6学习笔记</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Turbopack初识</h1><div class="container_mt6G margin-vert--md"><time datetime="2022-10-29T00:00:00.000Z" itemprop="datePublished">2022年10月29日</time> · <!-- -->阅读需 8 分钟</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>Turbopack 建立在新的增量架构上，以提供最快的开发体验。 在大型应用程序上，它显示更新速度比 Vite 快 10 倍，比 Webpack 快 700 倍。 在更大的应用程序上，差异更大——通常比 Vite 快 20 倍。</p><p>Turbopack 仅捆绑开发所需的最少资产，因此启动时间非常快。 在具有 3,000 个模块的应用程序上，Turbopack 需要 1.8 秒才能启动，而 Vite 需要 11.4 秒。</p><p><img loading="lazy" src="/assets/images/banner-264c11779b8e1c0ef38da3c1a69282f5.jpg" width="1247" height="490" class="img_ev3q"></p><p>Turbopack 是针对 JavaScript 和 TypeScript 优化的增量打包器，由 Vercel 的 Webpack 和 Next.js 的创建者用 Rust 编写。</p><p>在大型应用程序上，Turbopack 的更新速度比 Vite 快 10 倍，比 Webpack 快 700 倍。对于最大的应用程序，差异变得更加明显，更新速度比 Vite 快 20 倍。</p><p>Turbopack 性能的秘诀是双重的：高度优化的机器代码和低级增量计算引擎，可以缓存到单个函数的级别。一旦 Turbopack 执行了一项任务，它就再也不会这样做了。</p><p>我们的团队吸取了 Webpack 10 年的经验教训，结合了 Turborepo 和 Google 的 Bazel 在增量计算方面的创新，并创建了一个可以支持未来几十年计算的架构。</p><div class="theme-admonition theme-admonition-tip alert alert--success admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span>提示</div><div class="admonitionContent_S0QG"><p>Turbopack 目前处于 alpha 阶段。它还没有准备好用于生产。感谢您的支持和反馈，因为我们正在努力为每个人做好准备</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="核心概念">核心概念<a class="hash-link" href="#核心概念" title="标题的直接链接">​</a></h2><p>让我们深入了解 Turbopack 的内部结构，找出它为何如此之快。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="涡轮发动机">涡轮发动机<a class="hash-link" href="#涡轮发动机" title="标题的直接链接">​</a></h3><p>Turbopack 之所以如此之快，是因为它建立在一个可重用的 Rust 库之上，该库支持称为 Turbo 引擎的增量计算。这是它的工作原理：</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="函数级缓存">函数级缓存<a class="hash-link" href="#函数级缓存" title="标题的直接链接">​</a></h3><p>在 Turbo 引擎驱动的程序中，您可以将某些功能标记为“要记住”。当这些函数被调用时，Turbo 引擎会记住它们被调用的内容，以及它们返回的内容。然后它将其保存在内存缓存中。</p><p><img loading="lazy" src="/assets/images/turbo-engine-first-run-c1e625571bc3497d4bd21db2d87aeeef.webp" width="1742" height="654" class="img_ev3q"></p><p>我们首先调用<code>readFile</code>两个文件，<code>api.ts</code>和<code>sdk.ts</code>。然后我们将<code>bundle</code>这些文件<code>concat</code>放在一起，最后得到<code>fullBundle</code>。所有这些函数调用的结果都保存在缓存中以备后用。</p><p>假设我们在开发服务器上运行。您将<code>sdk.ts</code>文件保存在您的机器上。<code>Turbopack</code>接收到文件系统事件，并知道它需要重新计算<code>readFile(&quot;sdk.ts&quot;)</code>：</p><p><img loading="lazy" src="/assets/images/turbo-engine-second-run-5c9dd6a904afa4163f6298d665eb81f2.webp" width="1742" height="654" class="img_ev3q"></p><p>由于结果<code>sdk.ts</code>已经改变，我们需要<code>bundle</code>再次连接它，然后需要再次连接。</p><p>至关重要的是，<code>api.ts</code>没有改变。我们从缓存中读取它的结果并将其传递给<code>concat</code>。因此，我们通过不阅读并重新打包来节省时间。</p><p>现在想象一下，在一个真正的捆绑器中，有数千个文件要读取和转换要执行。心智模型是一样的。您可以通过记住函数调用的结果而不是重复以前完成的工作来节省大量工作。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="缓存">缓存<a class="hash-link" href="#缓存" title="标题的直接链接">​</a></h2><p>Turbo 引擎当前将其缓存存储在内存中。这意味着缓存将与运行它的进程一样长 - 这对于开发服务器来说效果很好。在 Next v13 中运行<code>next dev --turbo</code>时，您将使用 Turbo 引擎启动缓存。当您取消开发服务器时，缓存将被清除。</p><p>将来，我们计划将这个缓存持久化——要么保存到文件系统，要么保存到像 Turborepo 这样的远程缓存。这意味着 Turbopack 可以记住<strong>跨运行和机器完成的工作</strong>。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="优势">优势<a class="hash-link" href="#优势" title="标题的直接链接">​</a></h3><p>这种方法使 Turbopack 在计算应用程序的增量更新方面非常快速。这优化了 Turbopack 以处理开发中的更新，这意味着您的开发服务器将始终快速响应更改。</p><p>未来，持久缓存将为更快的生产构建打开大门。通过记住跨运行完成的工作，新的生产构建只能重建更改的文件 - 可能会节省大量时间。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="按需编译">按需编译<a class="hash-link" href="#按需编译" title="标题的直接链接">​</a></h3><p>Turbo 引擎有助于在您的开发服务器上提供极快的更新，但还有另一个重要指标需要考虑 - 启动时间。您的开发服务器开始运行的速度越快，您开始工作的速度就越快。</p><p>有两种方法可以使流程更快 - 工作更快，或做更少的工作。启动开发服务器，减少工作量的方法是只编译启动所需的代码。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="页面级编译">页面级编译<a class="hash-link" href="#页面级编译" title="标题的直接链接">​</a></h3><p>2-3 年前的 Next.js 版本用于在显示您的开发服务器之前<strong>编译整个应用程序</strong>。在 Next.js <!-- -->[11]<!-- --> 中，我们开始只<strong>编译请求的页面的代码</strong>。</p><p>这更好，但并不完美。当您导航到 时/users，我们将捆绑所有客户端和服务器模块、动态导入的模块以及引用的 CSS 和图像。这意味着如果您的页面的很大一部分隐藏在视图之外，或者隐藏在选项卡后面，我们仍然会对其进行编译。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="请求级编译">请求级编译<a class="hash-link" href="#请求级编译" title="标题的直接链接">​</a></h3><p>Turbopack 足够聪明，可以只编译您请求的代码。这意味着如果浏览器请求 HTML，我们只编译 HTML——而不是 HTML 引用的任何内容。</p><p>如果浏览器需要一些 CSS，我们将只编译它——而不编译引用的图像。背后有一个大的图表库<code>next/dynamic</code>吗？在显示图表的选项卡显示之前不编译它。Turbopack 甚至知道不编译源映射，除非您的 Chrome DevTools 是打开的。</p><p>如果我们使用原生 ESM，我们会得到类似的行为。除了 Native ESM 向服务器产生大量请求外，正如我们为什么选择 Turbopack 部分所讨论的那样。通过请求级编译，我们既可以减少请求的数量，又可以使用本机速度来编译它们。正如您在我们的基准测试中看到的那样，这提供了显着的性能改进。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="参考资料">参考资料<a class="hash-link" href="#参考资料" title="标题的直接链接">​</a></h4><p>【原文引用】<a href="https://turbo.build/pack/docs" target="_blank" rel="noopener noreferrer">Turbopack Quickstart – Turbopack</a></p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col"><b>标签：</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/turbopack">Turbopack</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/webpack">Webpack</a></li><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/vite">Vite</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/uml"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">Picturing Architecture</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/docusaurus"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">hexo转docusaurus</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#核心概念" class="table-of-contents__link toc-highlight">核心概念</a><ul><li><a href="#涡轮发动机" class="table-of-contents__link toc-highlight">涡轮发动机</a></li><li><a href="#函数级缓存" class="table-of-contents__link toc-highlight">函数级缓存</a></li></ul></li><li><a href="#缓存" class="table-of-contents__link toc-highlight">缓存</a><ul><li><a href="#优势" class="table-of-contents__link toc-highlight">优势</a></li><li><a href="#按需编译" class="table-of-contents__link toc-highlight">按需编译</a></li><li><a href="#页面级编译" class="table-of-contents__link toc-highlight">页面级编译</a></li><li><a href="#请求级编译" class="table-of-contents__link toc-highlight">请求级编译</a></li></ul></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/iiLsss/iiLsss.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 地球, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8769d743.js"></script>
<script src="/assets/js/main.44404fa1.js"></script>
</body>
</html>