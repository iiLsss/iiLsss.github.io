"use strict";(self.webpackChunkdiqiu_website=self.webpackChunkdiqiu_website||[]).push([[1741],{3905:(e,n,r)=>{r.d(n,{Zo:()=>s,kt:()=>p});var t=r(7294);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function l(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function a(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?l(Object(r),!0).forEach((function(n){i(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):l(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function d(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},l=Object.keys(e);for(t=0;t<l.length;t++)r=l[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)r=l[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var o=t.createContext({}),c=function(e){var n=t.useContext(o),r=n;return e&&(r="function"==typeof e?e(n):a(a({},n),e)),r},s=function(e){var n=c(e.components);return t.createElement(o.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},b=t.forwardRef((function(e,n){var r=e.components,i=e.mdxType,l=e.originalType,o=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),b=c(r),p=i,F=b["".concat(o,".").concat(p)]||b[p]||u[p]||l;return r?t.createElement(F,a(a({ref:n},s),{},{components:r})):t.createElement(F,a({ref:n},s))}));function p(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var l=r.length,a=new Array(l);a[0]=b;var d={};for(var o in n)hasOwnProperty.call(n,o)&&(d[o]=n[o]);d.originalType=e,d.mdxType="string"==typeof e?e:i,a[1]=d;for(var c=2;c<l;c++)a[c]=r[c];return t.createElement.apply(null,a)}return t.createElement.apply(null,r)}b.displayName="MDXCreateElement"},6932:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>c});var t=r(7462),i=(r(7294),r(3905));const l={},a="DOM-DIFF",d={unversionedId:"react/dom-diff",id:"react/dom-diff",title:"DOM-DIFF",description:"\u5728 React17+\u4e2d DOM-DIFF \u5c31\u662f\u8001\u7684 Fiber \u6811\u548c\u65b0\u7684\u865a\u62df DOM \u5bf9\u6bd4\u751f\u6210\u65b0\u7684 Fiber \u7684\u8fc7\u7a0b",source:"@site/docs/react/dom-diff.md",sourceDirName:"react",slug:"/react/dom-diff",permalink:"/docs/react/dom-diff",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"react",previous:{title:"LifeCycle",permalink:"/docs/react/LifeCycle"}},o={},c=[{value:"\u5355\u8282\u70b9",id:"\u5355\u8282\u70b9",level:2},{value:"\u591a\u8282\u70b9",id:"\u591a\u8282\u70b9",level:2}],s={toc:c};function u(e){let{components:n,...l}=e;return(0,i.kt)("wrapper",(0,t.Z)({},s,l,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dom-diff"},"DOM-DIFF"),(0,i.kt)("p",null,"\u5728 React17+\u4e2d DOM-DIFF \u5c31\u662f\u8001\u7684 Fiber \u6811\u548c\u65b0\u7684\u865a\u62df DOM \u5bf9\u6bd4\u751f\u6210\u65b0\u7684 Fiber \u7684\u8fc7\u7a0b"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u4f18\u5316\u539f\u5219")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"\u53ea\u5bf9\u540c\u7ea7\u8282\u70b9\u8fdb\u884c\u5bf9\u6bd4\uff0c\u5982\u679c DOM \u8282\u70b9\u8de8\u5c42\u7ea7\u79fb\u52a8\uff0c\u4e0d\u4f1a\u590d\u7528"),(0,i.kt)("li",{parentName:"ul"},"\u4e0d\u540c\u7c7b\u578b\u8282\u70b9\u7684\u5bf9\u6bd4\uff0c\u4f1a\u9500\u6bc1\u8001\u8282\u70b9\u53ca\u5b50\u5b59\u8282\u70b9\uff0c\u521b\u5efa\u65b0\u7684\u8282\u70b9"),(0,i.kt)("li",{parentName:"ul"},"\u901a\u8fc7 key \u6807\u8bc6\u540c\u4e00\u4e2a\u8282\u70b9")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"\u8fdb\u884c\u5bf9\u6bd4")),(0,i.kt)("p",null,(0,i.kt)("img",{src:r(7300).Z,width:"1662",height:"1038"})),(0,i.kt)("h2",{id:"\u5355\u8282\u70b9"},"\u5355\u8282\u70b9"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"key \u76f8\u540c type \u76f8\u540c \u53ef\u4ee5\u590d\u7528\u8be5\u8282\u70b9"),(0,i.kt)("li",{parentName:"ul"},"key \u4e0d\u76f8\u540c\u76f4\u63a5\u6807\u8bb0\u5220\u9664\uff0c\u521b\u5efa\u65b0\u8282\u70b9"),(0,i.kt)("li",{parentName:"ul"},"key \u76f8\u540c type \u4e0d\u540c \u6807\u8bb0\u5220\u9664")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// packages\\react-reconciler\\src\\ReactChildFiber.old.js\nfunction reconcileSingleElement(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  element: ReactElement,\n  lanes: Lanes\n): Fiber {\n  const key = element.key;\n  let child = currentFirstChild;\n  while (child !== null) {\n    // TODO: If key === null and child.key === null, then this only applies to\n    // the first item in the list.\n    if (child.key === key) {\n      switch (child.tag) {\n        case Fragment: {\n          if (element.type === REACT_FRAGMENT_TYPE) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n            return existing;\n          }\n          break;\n        }\n        case Block:\n          if (enableBlocksAPI) {\n            let type = element.type;\n            if (type.$$typeof === REACT_LAZY_TYPE) {\n              type = resolveLazyType(type);\n            }\n            if (type.$$typeof === REACT_BLOCK_TYPE) {\n              // The new Block might not be initialized yet. We need to initialize\n              // it in case initializing it turns out it would match.\n              if (\n                ((type: any): BlockComponent<any, any>)._render ===\n                (child.type: BlockComponent<any, any>)._render\n              ) {\n                deleteRemainingChildren(returnFiber, child.sibling);\n                const existing = useFiber(child, element.props);\n                existing.type = type;\n                existing.return = returnFiber;\n                if (__DEV__) {\n                  existing._debugSource = element._source;\n                  existing._debugOwner = element._owner;\n                }\n                return existing;\n              }\n            }\n          }\n        // We intentionally fallthrough here if enableBlocksAPI is not on.\n        // eslint-disable-next-lined no-fallthrough\n        default: {\n          if (\n            child.elementType === element.type ||\n            // Keep this check inline so it only runs on the false path:\n            (__DEV__\n              ? isCompatibleFamilyForHotReloading(child, element)\n              : false)\n          ) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props);\n            existing.ref = coerceRef(returnFiber, child, element);\n            existing.return = returnFiber;\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n            return existing;\n          }\n          break;\n        }\n      }\n      // Didn't match.\n      deleteRemainingChildren(returnFiber, child);\n      break;\n    } else {\n      deleteChild(returnFiber, child);\n    }\n    child = child.sibling;\n  }\n\n  if (element.type === REACT_FRAGMENT_TYPE) {\n    const created = createFiberFromFragment(\n      element.props.children,\n      returnFiber.mode,\n      lanes,\n      element.key\n    );\n    created.return = returnFiber;\n    return created;\n  } else {\n    const created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, currentFirstChild, element);\n    created.return = returnFiber;\n    return created;\n  }\n}\n")),(0,i.kt)("h2",{id:"\u591a\u8282\u70b9"},"\u591a\u8282\u70b9"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"key \u4e0d\u76f8\u540c\u76f4\u63a5\u5220\u9664\uff0c\u521b\u5efa\u65b0\u7684\u8282\u70b9"),(0,i.kt)("li",{parentName:"ul"},"\u591a\u8282\u70b9\u4f1a\u7ecf\u5386\u4e24\u8f6e\u904d\u5386"),(0,i.kt)("li",{parentName:"ul"},"\u79fb\u52a8\u89c4\u5219\u65e7\u8282\u70b9 index \u5927\u7684\u5f80\u540e\u79fb")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"// packages\\react-reconciler\\src\\ReactChildFiber.old.js\nfunction reconcileChildrenArray(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChildren: Array<*>,\n  lanes: Lanes\n): Fiber | null {\n  let resultingFirstChild: Fiber | null = null;\n  let previousNewFiber: Fiber | null = null;\n\n  let oldFiber = currentFirstChild;\n  let lastPlacedIndex = 0;\n  let newIdx = 0;\n  let nextOldFiber = null;\n  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n    if (oldFiber.index > newIdx) {\n      nextOldFiber = oldFiber;\n      oldFiber = null;\n    } else {\n      nextOldFiber = oldFiber.sibling;\n    }\n    const newFiber = updateSlot(\n      returnFiber,\n      oldFiber,\n      newChildren[newIdx],\n      lanes\n    );\n    if (newFiber === null) {\n      if (oldFiber === null) {\n        oldFiber = nextOldFiber;\n      }\n      break;\n    }\n    if (shouldTrackSideEffects) {\n      if (oldFiber && newFiber.alternate === null) {\n        deleteChild(returnFiber, oldFiber);\n      }\n    }\n    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n    if (previousNewFiber === null) {\n      resultingFirstChild = newFiber;\n    } else {\n      previousNewFiber.sibling = newFiber;\n    }\n    previousNewFiber = newFiber;\n    oldFiber = nextOldFiber;\n  }\n\n  if (newIdx === newChildren.length) {\n    deleteRemainingChildren(returnFiber, oldFiber);\n    return resultingFirstChild;\n  }\n\n  if (oldFiber === null) {\n    for (; newIdx < newChildren.length; newIdx++) {\n      const newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n      if (newFiber === null) {\n        continue;\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n    return resultingFirstChild;\n  }\n\n  const existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n  for (; newIdx < newChildren.length; newIdx++) {\n    const newFiber = updateFromMap(\n      existingChildren,\n      returnFiber,\n      newIdx,\n      newChildren[newIdx],\n      lanes\n    );\n    if (newFiber !== null) {\n      if (shouldTrackSideEffects) {\n        if (newFiber.alternate !== null) {\n          existingChildren.delete(\n            newFiber.key === null ? newIdx : newFiber.key\n          );\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        resultingFirstChild = newFiber;\n      } else {\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n    }\n  }\n\n  if (shouldTrackSideEffects) {\n    existingChildren.forEach((child) => deleteChild(returnFiber, child));\n  }\n\n  return resultingFirstChild;\n}\n")))}u.isMDXComponent=!0},7300:(e,n,r)=>{r.d(n,{Z:()=>t});const t=r.p+"assets/images/domf-diff-flow-33dea184c06e9413296c4ae59b28f30f.png"}}]);